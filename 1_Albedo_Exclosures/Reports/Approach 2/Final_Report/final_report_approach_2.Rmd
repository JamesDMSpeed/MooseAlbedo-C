---
output:
  html_document:
    self_contained: false
    lib_dir: libs
    css: styles.css
    toc: true
    df_print: paged
    number_sections: false
    theme: paper
    toc_float:
      collapsed: true
      smooth_scroll: true
    includes:
      before_body: markdown_intro.html
---

```{r echo = FALSE, results = "asis", message = FALSE, include = FALSE}

#Packages
library(dplyr)
library(ggplot2)
library(knitr)
library(kableExtra)
library(sp)
library(raster)
library(GGally)
library(lattice)
library(lme4)
library(sjPlot)
library(ggplot2)
library(RColorBrewer)
library(wesanderson)
library(rasterVis)
library(lidR)
library(geometry)
library(concaveman)

#INITIAL DATA IMPORT + FORMATTING ----------------------------------------------------------------------------------------------

        #Get 'cleaned' site data from adjacent 'Sites' folder
        site_data <- read.csv('../../../Data/SustHerb_Site_Data/cleaned_data/cleaned_data.csv', header = TRUE)
        
        #Load Plot Coordinates

                #Read in Regional coordinates
                plotcoords_trond <- read.csv('../../../Data/Site_Coordinates/troendelag_20m_flater_pkt.csv',header=T,sep=';', dec=',')
                plotcoords_hed_ask <- read.csv('../../../Data/Site_Coordinates/Koordinater_20x20_Hedmark_Akershus.csv',header=T,sep=';', dec=',')
                plotcoords_tel <- read.csv('../../../Data/Site_Coordinates/Koordinater_20x20_Telemark_formatted.csv',header=T,sep=';', dec=',', encoding = "UTF-8")
                
                ##Exclude sites without LiDAR data
                ##  (exclusions based on Ingrid Snøan's 'HedmarkTroendelagTelemarkSustherbSites' file)
                
                        #Hedmark Exclusions
                        hed_excl <- c("DD1", "DD2", "JCD1", "JCD2", "M1.1", "M1.2", "M2.1", "M2.2", "M3.1", "M3.2", "OIA1", "OIA2", "OL1", "OL2", "SK1", "SK2")
                        plotcoords_hed_ask <- plotcoords_hed_ask[!plotcoords_hed_ask$Uthegningi %in% hed_excl,]
                        
                        #Telemark Exclusions
                        tel_excl <- c("Notodden 1 B", "Notodden 1 UB", "Notodden 4 B", "Notodden 4 UB")
                        plotcoords_tel <- plotcoords_tel[!plotcoords_tel$flatenavn %in%  tel_excl,]
                
                #Create df to hold all coordinates
                plotcoords <- data.frame("Name" = '', "utm32north" = '', "utm32east" = '')
                
                        #Bind Trøndelag coordinates to main coordinates df
                        
                                #Filter down to relevant columns
                                plotcoords_trond_opt <- plotcoords_trond[, c(3:5)]

                                #Convert site codes to uppercase (to match 'site_data' format)
                                plotcoords_trond_opt$Name <- toupper(plotcoords_trond_opt$Name)
                                
                                #Rename columns
                                colnames(plotcoords_trond_opt)[2] <- "utm32east"
                                colnames(plotcoords_trond_opt)[3] <- "utm32north"
                                
                                #Correct extra space in '1NSUB' label
                                plotcoords_trond_opt$Name[plotcoords_trond_opt$Name == ' 1NSUB'] <- '1NSUB'
                
                                #Row bind with main coordinates df
                                plotcoords <- plotcoords_trond_opt
                                
                        #Bind Askerhus + Hedmark coordinates to main coordinates df
                                
                                #Filter down to relevant columns
                                plotcoords_hed_ask_opt <- plotcoords_hed_ask[, c(6, 14:15)]
                                
                                #Rename 'Name' column
                                colnames(plotcoords_hed_ask_opt)[1] <- "Name"
                                
                                #Swap 'coordinate codes' with SustHerb site codes
                                #Note: Using Ingrid's coordinate references here (number order b/t B and UB is a bit wonky)
                                
                                        #Didrik Holmsen UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'DH1'] <- 'DHUB'
                                        
                                        #Didrik Holmsen B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'DH2'] <- 'DHB'
                                        
                                        #Fet3 UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'FK1'] <- 'FKUB'
                                        
                                        #Fet3 B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'FK2'] <- 'FKB'
                                        
                                        #Halvard Pramhus UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'HP2'] <- 'HPUB'
                                        
                                        #Halvard Pramhus B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'HP1'] <- 'HPB'
                                        
                                        #Stig Dahlen UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SD1'] <- 'SDUB'
                                        
                                        #Stig Dahlen B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SD2'] <- 'SDB'
                                        
                                        #Stangeskovene Aurskog UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SSA2'] <- 'SSAUB'
                                        
                                        #Stangeskovene Aurskog B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SSA1'] <- 'SSAB'
                                        
                                        #Stangeskovene Eidskog UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SSB2'] <- 'SSBUB'
                                        
                                        #Stangeskovene Eidskog B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SSB1'] <- 'SSBB'
                                        
                                        #Eidskog UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'STSKN1'] <- 'STSKNUB'
                                        
                                        #Eidskog B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'STSKN2'] <- 'STSKNB'
                                        
                                        #Truls Holm UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'TH2'] <- 'THUB'
                                        
                                        #Truls Holm BB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'TH1'] <- 'THB'
                                        
                                        
                                        
                                        
                                #Row bind with main coordinates df
                                plotcoords <- rbind(plotcoords, plotcoords_hed_ask_opt)
                                
                        #Bind Telemark coordinates to main coordinates df
                                
                                #Filter down to relevant columns
                                plotcoords_tel_opt <- plotcoords_tel[, c(4, 9:10)]
                                
                                #Correct column names
                                colnames(plotcoords_tel_opt)[1] <- "Name"

                                #Remove unicode 'replacement character' in "Fritsoe" (to match site_data)
                                plotcoords_tel_opt$Name <- gsub('\uFFFD', 'o', plotcoords_tel_opt$Name)
                                
                                #Corrections to spelling (to match 'site_data' and allow for loop below)
                                        
                                        #Column to lowercase
                                        plotcoords_tel_opt$Name <- tolower(plotcoords_tel_opt$Name)
                                        
                                        #Fritsoe
                                        plotcoords_tel_opt$Name <- gsub('fritzoe', 'fritsoe', plotcoords_tel_opt$Name)
                                        
                                        #Cappelen
                                        plotcoords_tel_opt$Name <- gsub('cappelen', 'nome_cappelen', plotcoords_tel_opt$Name)
                                
                                        #Furesdal (Note: remove number '1' to match 'site_data')
                                        plotcoords_tel_opt$Name <- gsub('fyresdal 1', 'furesdal', plotcoords_tel_opt$Name)
                                
                                #Replace full name w/ relevant site code
                                        
                                        for(i in 1:nrow(plotcoords_tel_opt)){
                                                
                                                #Split string
                                                s <- strsplit(plotcoords_tel_opt[i, "Name"], split = " ")
                                                
                                                #Perform code below for all except furesdal
                                                if( s[[1]][1] == "furesdal" ){
                                                        
                                                        #Grab 'furesdal' string
                                                        s2 <- s[[1]][1]
                                                        
                                                        #Identify treatment
                                                        st <- s[[1]][2]
                                                        
                                                } else {
                                                        
                                                        #Join site name + number
                                                        s2 <- paste(s[[1]][1], s[[1]][2], sep = "")
                                                        
                                                        #Identify treatment
                                                        st <- s[[1]][3]
                                                        
                                                }
                                                
                                                if( st == "ub" ){
                                                        tr <- "exclosure"
                                                } else if ( st == "b" ){
                                                        tr <- "open"
                                                }
                                                
                                                #Get relevant site code
                                                ## Some sites not in site_data (these are given NA)
                                                if( (s2 %in% site_data$LocalityName) == T ) {
                                                        sc <- site_data$LocalityCode[site_data$LocalityName == s2 & site_data$Treatment == tr]
                                                } else {
                                                        sc <- NA
                                                }
                                                
                                                #Replace existing name w/ site code (or NA)
                                                plotcoords_tel_opt[i, "Name"] <- sc
                                                
                                        }

                                #Row bind with main coordinates df
                                plotcoords <- rbind(plotcoords, plotcoords_tel_opt)
                

#END INITIAL DATA IMPORT + FORMATTING --------------------------------------------------------------------------------
```
                                
                                
                                
                                
    

# Overview
This report contains a summary of 'Approach 2', which uses existing SustHerb LiDAR data from [Snøan (2019)](https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2618099?locale-attribute=no) to estimate volume (and ultimately, albedo) for relevant study plots. The report covers each step of the analysis and discusses potential limitations/assumptions associated with each step.

![](https://allyworks.io/moose-albedo/img/Approach_2_Flowchart.png)

***

# Data

### Data Selection {.tabset .tabset-fade .tabset-pills}

#### SustHerb Data
I chose to use data from SustHerb sites in Trøndelag, Telemark, and Hedmark **(n = 37)**. LiDAR data for these sites was previously processed by [Snøan (2019)](https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2618099?locale-attribute=no) - thus, I was able to use this LiDAR data as a starting point for my analysis. It is important to note that the following SustHerb sites are missing from my analysis (as they were missing from the analysis conducted by [Snøan (2019)](https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2618099?locale-attribute=no) and therefore, don't have existing LiDAR data):
* **Hedmark**: "DD1", "DD2", "JCD1", "JCD2", "M1.1", "M1.2", "M2.1", "M2.2", "M3.1", "M3.2", "OIA1", "OIA2", "OL1", "OL2", "SK1", "SK2"
* **Telemark**: "Notodden 1 B", "Notodden 1 UB", "Notodden 4 B", "Notodden 4 UB"

Additional variables for each plot that were included in the final model/analysis include "Years Since Exclosure" and "Number of Years Between Clearcut and LiDAR Measurement".

#### seNorge Climate Data
The albedo model developed by [Hu et al. (2018)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001403) accepts *two climate parameters*: (1) monthly average snow-water equivalent (mm) and (2) monthly average temperature (K). seNorge provides this data across the entire country of Norway in the form of spatially-gridded daily estimates with a 1km2 resolution. Thus, it was possible to use obtain relevant time series data for each study site used in this approach.

For each study site, I pulled snow-water equivalent and temperature data from the corresponding year of LiDAR measurement - so, for example, if a plot was measured with LiDAR in 2016, then I pulled climate data corresponding to that plot from 2016. Monthly averages of temperature (C) and snow-water equivalent (mm) were calculated from each time series. Temperature was converted to K for use with the albedo model. **The total number of temperature observations is therefore 444 (12 months x 37 sites). The total number of snow-water equivalent observations is also 444 (12 months x 37 sites)**.

#### Productivity Index
Site productivity is likely an important variable to control for when attempting to determine the effect of moose exclusion on forest surface albedo. Therefore, I decided to include data from the site productivity index that was developed by [Kolstad et al. (2017)](https://link.springer.com/article/10.1007/s10021-017-0202-4). This index is based upon a standardized value for mean annual increment in aboveground biomass. 

#### Herbivore Densities
Densities of various herbivores may have important effects on vegetation states within forest ecosystems, and therefore, it is likely relevant to control for relevant herbivore densities in our final analysis. In addition to moose, both red deer and roe deer are important herbivores in Norwegian boreal forests. Thus, I decided to include densities of moose, red deer, and roe deer in the final model for this approach.

[Speed et al. (2019)](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0217166) and [Austrheim et al. (2011)](https://bioone.org/journals/Wildlife-Biology/volume-17/issue-3/10-038/Spatio-temporal-variation-in-large-herbivore-pressure-in-Norway-during/10.2981/10-038.full) calculated metabolic biomass (kg/km2) of many different large herbivores in each Norwegian municipality (for 1949, 1959, 1969, 1979, 1989, 1999, 2009, and 2015), which allows us to include herbivore densities as covariates in our final model. Because this specific approach is using tree data from 2016, I decided to use herbivore data from the closest possible year (2015). For each Sustherb site, I pulled herbivore densities for the corresponding Norwegian kommune based on "Kommune ID".

#### Forest Canopy Height MAD
Surface roughness (and therefore forest canopy roughness) may be an important factor in surface albedo. [Snøan (2019)](https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2618099?locale-attribute=no) used airborne laser measurements (LiDAR) to examine the effects of moose exclusion on boreal forest canopy, and found that moose exclusion significantly altered forest canopy height mean absolute deviation (MAD), which is a metric for canopy roughness. Therefore, I decided to include the LiDAR-derived canopy MAD measurements produced by [Snøan (2019)](https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2618099?locale-attribute=no) in the final analysis for this approach.

### Data Summary {.tabset .tabset-fade .tabset-pills}

#### SustHerb Dataset {.tabset}

##### Summary
```{r echo = FALSE, eval= TRUE, message = FALSE}

        simple_sites <- site_data[,c(2,3,5,7,10,12,23)]

        #Taxa Table
        simple_sites

```

##### Tree Species Proportions
```{r echo = FALSE, eval= TRUE, message = FALSE}   

## SUSTHERB TREE SPECIES PROPORTIONS (At the PLOT level)
                        
#Tree density data for Trøndelag, Telemark, and Hedmark (including 2019 data)
tree_data <- read.csv('../../../Universal/Output/Tree_Species_Proportions/tree_species_proportions_plot_level.csv', header = TRUE)
tree_data <- tree_data[,2:7]

#Filter tree data to years that correspond with LiDAR Data
## Ex. BRB has LiDAR data from 2017, so get tree data from 2017 only

#Note: This also reduces the number of sites to 74 (as in Ingrid Snøan's analysis)

        #Filter out unused SustHerb sites
                
                #Convert site codes to factors
                tree_data$LocalityCode <- as.factor(tree_data$LocalityCode)
                site_data$LocalityCode <- as.factor(site_data$LocalityCode)
                
                #Get vector of levels for sites that will be used (n = 74)
                used_sites <- levels(site_data$LocalityCode)
                
                #Filter tree data to used sites
                tree_data <- tree_data[tree_data$LocalityCode %in% used_sites,]
                tree_data$LocalityCode <- as.factor(as.character(tree_data$LocalityCode))
                
        #For each site, filter out data from irrelevant years
        for(i in 1:length(site_data$X)){
                
                #Get site code and corresponding LiDAR year
                site_code <- site_data[i, "LocalityCode"]
                lidar_year <- site_data[i, "LiDAR.data.from.year"]
                
                #Filter down tree data (from all)
                
                #Get temp frame
                temp <- tree_data[tree_data$LocalityCode == site_code & tree_data$Year == lidar_year,]
                
                #Subtract observations w/ corresponding site code
                tree_data <- tree_data[tree_data$LocalityCode != site_code,]
                
                #Re-add temp frame
                tree_data <- rbind(tree_data, temp)
                
        }
        
        #Display df    
        tree_data
        
      
```

#### seNorge Data {.tabset}

##### Snow-Water Equivalent
```{r echo = FALSE, eval= TRUE, message = FALSE}        
        
        #Add monthly SWE averages from seNorge
        swe <- read.csv('../../../Universal/Output/SWE/monthly_avg_swe_mm.csv', header = TRUE)
                
        #Add monthly temperature averages from seNorge
        temps <- read.csv('../../../Universal/Output/Temperature/monthly_avg_temp_C.csv', header = TRUE)

                #Convert temps from celsius (C) to kelvin (K)
                for( i in 1:length(temps$X)){
                        #K = C + 273.15
                        temps[i, "Avg_Temp_C"] <- temps[i, "Avg_Temp_C"] + 273.15
                }
        
                #Rename column from C to K
                colnames(temps)[9] <- "Avg_Temps_K"
                
        #Remove sites not used in analysis
        site_data$LocalityCode <- as.factor(site_data$LocalityCode)
        swe$LocalityCode <- as.factor(swe$LocalityCode)
        temps$LocalityCode <- as.factor(temps$LocalityCode)
        
        checklist <- site_data[site_data$Treatment == "open",]
        checklist <- levels(as.factor(as.character(checklist$LocalityCode)))
        swe_filtered <- swe[swe$LocalityCode %in% checklist,]
        temps_filtered <- temps[temps$LocalityCode %in% checklist,]
        
        #Plot
        swe_filtered$Month <- as.numeric(swe_filtered$Month)
        ggplot(data = swe_filtered, aes(x = Month, y = SWE_mm, color = LocalityName)) +
                        geom_line() +
                        ggtitle("Monthly Avg. SWE at SustHerb Sites") +
                        labs(x = "Month", y = "SWE (mm)") +
                        scale_x_continuous(limits = c(0,12), breaks = c(1,2,3,4,5,6,7,8,9,10,11,12)) +
                        theme(
                                legend.position = "none"
                        )
        
        ggplot(data = swe_filtered, aes(x = Month, y = SWE_mm, color = LocalityName)) +
                geom_line() +
                facet_wrap(~ Year) +
                ggtitle("Monthly Avg. SWE at SustHerb Sites\n(by Corresponding Year of LiDAR Data)") +
                labs(x = "Month", y = "SWE (mm)") +
                scale_x_continuous(limits = c(0,12), breaks = c(1,2,3,4,5,6,7,8,9,10,11,12)) +
                theme(
                        legend.position = "none"
                )

        swe_filtered$Month <- as.factor(swe_filtered$Month)
        ggplot(data = swe_filtered, aes(x = Month, y = SWE_mm)) +
                geom_boxplot() +
                ggtitle("Monthly Avg. SWE at SustHerb Sites (by Month)") +
                labs(x = "Month", y = "SWE (mm)")
        
        ggplot(data = swe_filtered, aes(x = SWE_mm)) +
                geom_histogram() +
                facet_wrap(~ Month) +
                ggtitle("Monthly Avg. SWE at SustHerb Sites (by Month)") +
                labs(x = "Avg. SWE (mm)", y = "Count")
        
```

##### Temperature
```{r echo = FALSE, eval= TRUE, message = FALSE}        

        #Plot
        temps_filtered$Month <- as.numeric(temps_filtered$Month)
        ggplot(data = temps_filtered, aes(x = Month, y = Avg_Temps_K, color = LocalityName)) +
                        geom_line() +
                        ggtitle("Monthly Avg. Temperature at SustHerb Sites") +
                        labs(x = "Month", y = "Temperature (K)") +
                        scale_x_continuous(limits = c(0,12), breaks = c(1,2,3,4,5,6,7,8,9,10,11,12)) +
                        theme(
                                legend.position = "none"
                        )
        
        ggplot(data = temps_filtered, aes(x = Month, y = Avg_Temps_K, color = LocalityName)) +
                geom_line() +
                facet_wrap(~ Year) +
                ggtitle("Monthly Avg. Temperature at SustHerb Sites\n(by Corresponding Year of LiDAR Data)") +
                labs(x = "Month", y = "Temperature (K)") +
                scale_x_continuous(limits = c(0,12), breaks = c(1,2,3,4,5,6,7,8,9,10,11,12)) +
                theme(
                        legend.position = "none"
                )

        temps_filtered$Month <- as.factor(temps_filtered$Month)
        ggplot(data = temps_filtered, aes(x = Month, y = Avg_Temps_K)) +
                geom_boxplot() +
                ggtitle("Monthly Avg. Temperature at SustHerb Sites (by Month)") +
                labs(x = "Month", y = "Avg. Temperature (K)")
        
        ggplot(data = temps_filtered, aes(x = Avg_Temps_K)) +
                geom_histogram() +
                facet_wrap(~ Month) +
                ggtitle("Monthly Avg. Temperature at SustHerb Sites (by Month)") +
                labs(x = "Avg. Temperature (K)", y = "Count")


```

#### Productivity Index
```{r echo = FALSE, eval = TRUE, message = FALSE}

#Productivity Data
productivity <- read.csv('../../../Data/SustHerb_Site_Data/productivity_all_sites.csv', header = TRUE)
productivity$LocalityName <- tolower(productivity$LocalityName)

        #Correct LocalityName items in productivity CSV
        
                #Didrik Holmsen
                productivity$LocalityName[productivity$LocalityName == "didrik holmsen"] <- "didrik_holmsen"
                
                #Fet 3
                productivity$LocalityName[productivity$LocalityName == "fet 3"] <- "fet_3"
                
                #Fritsøe 1
                productivity$LocalityName[productivity$LocalityName == "fritsøe1"] <- "fritsoe1"
                
                #Fritsøe 2
                productivity$LocalityName[productivity$LocalityName == "fritsøe2"] <- "fritsoe2"
                
                #Halvard Pramhus
                productivity$LocalityName[productivity$LocalityName == "halvard pramhus"] <- "halvard_pramhus"
                
                #Singsaas
                productivity$LocalityName[productivity$LocalityName == "singsås"] <- "singsaas"
                
                #Stangeskovene Aurskog
                productivity$LocalityName[productivity$LocalityName == "stangeskovene aurskog"] <- "stangeskovene_aurskog"
                
                #Stangeskovene Eidskog
                productivity$LocalityName[productivity$LocalityName == "stangeskovene eidskog"] <- "stangeskovene_eidskog"
                
                #Stig Dahlen
                productivity$LocalityName[productivity$LocalityName == "stig dæhlen"] <- "stig_dahlen"
                
                #Truls Holm
                productivity$LocalityName[productivity$LocalityName == "truls holm"] <- "truls_holm"
        
        #Create corrected version of checklist
        for(i in 1:length(checklist)){
                checklist2[i] <- site_data$LocalityName[site_data$LocalityCode == checklist[i]]
        }

        #Remove LocalityNames not in tree dataset
        productivity <- productivity[productivity$LocalityName %in% checklist2,]
        prod_display <- productivity[,2:4]
        
        prod_display
        
        ggplot(data = prod_display, aes(x = Productivity)) +
                geom_histogram(aes(y=..density..), bins = 20, alpha=1, position="identity") +
                geom_density(alpha= 0.5) +
                ggtitle("Productivity Index Across SustHerb Sites") +
                labs(x = "Productivity Index (0-1)", y = "Density")
        
```

#### Herbivore Densities
```{r echo = FALSE, eval = TRUE, message = FALSE}

        #Read in herbivore biomass data from SpatialPolygons object (isolate dataframe)
        hbiomass_shp <- shapefile("../../../Data/Herbivore_Densities/NorwayLargeHerbivores")
        
        #Pull out dataframe
        hbiomass <- hbiomass_shp@data
        
        #Isolate 2015 data
        hbiomass2015 <- cbind(hbiomass[,c(1:10)], hbiomass$Ms_2015, hbiomass$Rd__2015, hbiomass$R_d_2015)
        
        #Isolate 2009 data
        hbiomass2009 <- cbind(hbiomass[,c(1:10)], hbiomass$Ms_2009, hbiomass$Rd__2009, hbiomass$R_d_2009)
        
        #Get list of Kommune IDs
        site_data$DistrictID <- as.factor(site_data$DistrictID)
        kommunes <- levels(site_data$DistrictID)
        
        #Create placeholder df w/ 37 blank rows
        herb_dens_display <- data.frame("LocalityName" = character(),
                                        "Moose_Density" = double(),
                                        "Red_Deer_Density" = double(),
                                        "Roe_Deer_Density" = double(),
                                        "Lidar_Year" = integer(),
                                        "Herbivore_Data_Year" = integer())
        herb_dens_display[nrow(herb_dens_display)+37,] <- NA
        
        checklist2 <- as.vector(checklist2)
        
        for(i in 1:length(checklist2)){
                
                #Get LocalityName
                herb_dens_display[i, "LocalityName"] <- checklist2[i]
                
                #District ID
                d_id <- site_data$DistrictID[site_data$LocalityName == checklist2[i]]
                
                #Get LiDAR year
                lidar_yr <- site_data$LiDAR.data.from.year[site_data$LocalityName == checklist2[i]][1]
                herb_dens_display[i, "Lidar_Year"] <- lidar_yr
                
                #Get closest herbivore density year (from lidar year) & add year + densities
                if(lidar_yr <= 2011){
                        
                        herb_dens_display[i, "Herbivore_Data_Year"] <- 2009
                        herb_dens_display[i, "Moose_Density"] <- hbiomass_filt_2009$Moose_Density[hbiomass_filt_2009$KOMMUNE == d_id]
                        herb_dens_display[i, "Red_Deer_Density"] <- hbiomass_filt_2009$Red_Deer_Density[hbiomass_filt_2009$KOMMUNE == d_id]
                        herb_dens_display[i, "Roe_Deer_Density"] <- hbiomass_filt_2009$Roe_Deer_Density[hbiomass_filt_2009$KOMMUNE == d_id]
                
                } else if (lidar_yr > 2011){
                        
                        herb_dens_display[i, "Herbivore_Data_Year"] <- 2015
                        herb_dens_display[i, "Moose_Density"] <- hbiomass_filt_2015$Moose_Density[hbiomass_filt_2015$KOMMUNE == d_id]
                        herb_dens_display[i, "Red_Deer_Density"] <- hbiomass_filt_2015$Red_Deer_Density[hbiomass_filt_2015$KOMMUNE == d_id]
                        herb_dens_display[i, "Roe_Deer_Density"] <- hbiomass_filt_2015$Roe_Deer_Density[hbiomass_filt_2015$KOMMUNE == d_id]
                
                }

        }
        
        #Display df
        herb_dens_display
        
        #Mutate df for plotting
        herb_dens_plot <- data.frame("LocalityName" = character(),
                                        "Density" = double(),
                                        "Herbivore" = double(),
                                        "Herbivore_Data_Year" = integer())
        
        for(i in 1:nrow(herb_dens_display)){
                
                tmp <- data.frame("LocalityName" = character(),
                                        "Density" = double(),
                                        "Herbivore" = double(),
                                        "Herbivore_Data_Year" = integer())
                tmp[nrow(tmp)+(3),] <- NA
                
                tmp$LocalityName <- herb_dens_display[i, "LocalityName"]
                tmp$Herbivore_Data_Year <- herb_dens_display[i, "Herbivore_Data_Year"]
                
                #Moose Density
                tmp[1, "Density"] <- herb_dens_display[i, "Moose_Density"]
                tmp[1, "Herbivore"] <- "Moose"
                
                #Red Deer Density
                tmp[2, "Density"] <- herb_dens_display[i, "Red_Deer_Density"]
                tmp[2, "Herbivore"] <- "Red Deer"
                
                #Roe Deer Density
                tmp[3, "Density"] <- herb_dens_display[i, "Roe_Deer_Density"]
                tmp[3, "Herbivore"] <- "Roe Deer"
                
                herb_dens_plot <- rbind(herb_dens_plot, tmp)
        }
        
        ggplot(data = herb_dens_plot, aes(x = Herbivore, y = Density)) +
                geom_boxplot() +
                ggtitle("Herbivore Densities Across Kommunes With SustHerb Sites") +
                labs(x = "Herbivore", y = "Metabolic Density (kg/km2)")
                
        
```

***

#Volume Calculations {.tabset .tabset-fade .tabset-pills}

## Reasoning 

##### Using LiDAR to calculate volumes of convex hulls around trees:
**The goal with this step was to calculate the volumes of convex hulls around each tree in a given plot**, which could then be summed and used as the 'volume' parameter in the volume-based albedo model developed by [Hu et al. (2018)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001403). Established methods could be used to identify and delineate inidividual trees within a LiDAR footprint of each SustHerb plot (specifically, by using the [lidR package](https://github.com/Jean-Romain/lidR) and associated methods). For each delineated tree, I thought it could be possible to use the methods in [Tao et al. (2014)](https://www.sciencedirect.com/science/article/pii/S0168192314001750) to calculate 



. By using These volumes would then be summed at the plot level and used to estimate albedo for each plot. Initially, I wanted to use species-specific *allometric tree volume equations*, which were developed by the Norwegian National Forest Inventory (NFI) for use in Norway. In fact, these equations were used to calculate forest stand volume for the test plots on which the volume parameter of the [SatSkog data product](https://www.nibio.no/tema/skog/kart-over-skogressurser/satskog) is based upon. FYI - the albedo model developed by [Hu et al. (2018)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001403) is based upon the SatSkog product. The equations are available in the form of an R package called ["sitreeE"](https://www.rdocumentation.org/packages/sitreeE/versions/0.0-5), but are based on volume tables developed by [Braastad (1966)](https://scholar.google.com/scholar?hl=en&as_sdt=0%2C5&q=Braastad+%281966%29&btnG=), [Brantseg (1967)](https://scholar.google.com/scholar?hl=en&as_sdt=0%2C5&q=+Brantseg+%281967%29&btnG=), and [Vestjordet (1967)](https://scholar.google.com/scholar?hl=en&as_sdt=0%2C5&q=+Vestjordet+%281967%29&btnG=).

However, after testing these equations on the dataset, I found that most estimates of volume (especially those for trees <150cm in height) were negative or obviously erroneous. It seems that the NFI allometric volume equations only perform well for trees that have a certain height or diameter, and wouldn't be useful for the dataset that we have.

I also investigated other allometric volume equations specific to Norwegian tree species of interest. The online database [GlobAllomeTree](http://www.globallometree.org/) contains many relevant equations. However, most of these equations require a *diameter at breast height (DBH)* measurement, as opposed to a DGL measurement (which is what a majority of trees in the dataset have). Additionally, a review by [Zianis et al. (2005)](https://www.researchgate.net/publication/232304857_Biomass_and_stem_volume_equations_of_tree_species_in_Europe) shows that almost all allometric volume equations for species of interest are limited to trees with a diameter of several centimeters or a height of 1.5 meters.

**Key point: using existing allometric volume equations doesn't seem possible for this approach.**

##### Converting from biomass to volume:
Without more detailed and impractical data (such as measurements of trunk diameter at evenly-spaced intervals along each tree), other methods of calculating volume didn't seem to be possible. However, [Kolstad et al. (2017)](https://link.springer.com/article/10.1007/s10021-017-0202-4) previously produced species-specific, locally-calibrated allometric biomass models. I thought that we could use these models to calculate biomass (g) for each tree in the dataset, and then somehow convert that biomass to volume (m3). 

There is abundant literature which focuses on converting tree volume to biomass (for carbon accounting purposes). However, I have not been able to find relevant literature related to converting tree *biomass to volume*. My first thought was that if we knew wood density for each tree species of interest, we could use the simple equation $Volume = mass / density$ to estimate volume from biomass. 

However, using wood density in this manner may be substantially flawed. [Repola (2006)](https://jukuri.luke.fi/handle/10024/532618) found that vertical wood density gradients are present in Norwegian species of interest - that is, wood density changes throughout the vertical length of a given tree trunk. Thus, attempting to calculate tree volume from a single wood density value may produce innacurate volume estimates and introduce substantial error into subsequent steps of the approach. Despite this issue, there didn't seem to be a better way to calculate volume for each tree from available data. 

For the wood densities (also sometimes referred to as 'specific gravities'), I chose to use the "**measured densities**" from [Repola (2006)](https://jukuri.luke.fi/handle/10024/532618). These densities were produced by measuring the density of 2-3cm disks taken at a 1m interval for the entire length of 327 pine, 317 spruce, and 192 birch specimens (harvested in Finland, not Norway). For each species, densities were averaged to produce a corresponding "measured density".

It is important to note that DBH of trees sampled by [Repola (2006)](https://jukuri.luke.fi/handle/10024/532618) ranged from 5-48 cm. Additionally, the minimum age of trees sampled was estimated to be 20 years old. These sample characteristics ultimately represent another source of error - most of the trees in the SustHerb dataset are much smaller and younger, and therefore, may have completely different densities than those provided by [Repola (2006)](https://jukuri.luke.fi/handle/10024/532618).

**Key point: best option to calculate volume seemed to be $Volume = mass/density$. Densities taken from [Repola (2006)](https://jukuri.luke.fi/handle/10024/532618)**

##### Handling less-common species
The dataset includes observations of two species - *Juniperus communis* and *Salix caprea* - which don't have corresponding allometric equations and are less common than the main species of interest. For the purposes of this approach, I essentially categorized *J. communis* to be the same as *Picea abies* - the allometric biomass equations and wood densities specific to *P. abies* are used on all observations of *J. communis*. I didn't have a great justification for lumping *J. communis* together with *P. abies* as opposed to *Pinus sylvestris* - only that *J. communis* is coniferous and may have smaller needles which are more similar to those of *P. abies*.

I also categorized *S. caprea* together with *Betula sp.* - the allometric equations and wood densities specific to *Betula sp.* are used on all observations of *S. caprea*. Again, I didn't really have a great justification for lumping *S. caprea* together with *Betula sp.* instead of *Sorbus aucuparia* - only that *S. caprea* and *Betula sp.* are both deciduous.

> What is your opinion regarding my grouping of *J. communis* with *P. abies* and *S. caprea* with *Betula sp.*, as described above? Any suggestions?


## Methods

1. Looped through each individual tree observation in the filtered dataset
2. Calculated biomass (g) for each tree using the locally-calibrated allometric equations developed by [Kolstad et al. (2017)](https://link.springer.com/article/10.1007/s10021-017-0202-4):
    + *Betula pubescens, Betula pendula, & Salix caprea*:
        + $Biomass = 0.078843(dgl^2)+0.009197(height^2)$
    + *Picea abies & Juniperus communis*
        + $Biomass = 0.020293(height^2)+0.006092(dgl^3)$
    + *Pinus sylvestris*
        + $Biomass = 0.325839(dgl^2)+0.0007434(dgl^3)$
    + *Sorbus aucuparia* (in browsed plots)
        + $Biomass = 0.006664(height^2)+0.082983(dgl^2)$
    + *Sorbus aucuparia* (in exclosures)
        + $Biomass = 0.0053962(height^2)$
3. From biomass (g) for each tree, I calculated volume (cm3) by using the simple equation: $Volume = mass/density$. I chose to use average 'measured densities' for *Betula sp.*, *P. abies*, and *P. sylvestris*, which were calculated by [Repola (2006)](https://jukuri.luke.fi/handle/10024/532618). Densities were converted from kg/m3 to g/cm3 for this step:
    + *Betula pubescens, Betula pendula, Salix caprea, & Sorbus aucuparia*:
        + Density: 475.0 kg/m3
    + *Picea abies & Juniperus communis*
        + Density: 385.3 kg/m3
    + *Pinus sylvestris*
        + Density: 412.6 kg/m3
4. Volume (cm3) was converted to m3 for use in the albedo model
5. The volumes (m3) of each tree were aggregated and summed by plot, in order to produce plot-level volume estimates. **Note:** a given plot-level volume estimate is the sum of all corresponding circular subplots. It is therefore NOT directly comparable to the volumes estimated by the other approaches in this project. 
    

## Results

#### Volume {.tabset}

##### Boxplot
```{r echo = FALSE, eval= TRUE, message = FALSE}

        ggplot(data = subplot_sums, aes(x = Treatment, y = Volume_m3, fill = Treatment)) +
                geom_boxplot() +
                ggtitle("Range of plot volumes for SustHerb study sites") +
                labs(x = "Site Treatment", y = bquote("Summed plot volume"~(m^3)))

```

##### Histogram
```{r echo = FALSE, eval= TRUE, message = FALSE}

        ggplot(data = subplot_sums, aes(x = Volume_m3, fill = Treatment, group = Treatment)) +
                geom_histogram(aes(y=..density..), bins = 30, alpha=1, position="identity") +
                geom_density(alpha= 0.5) +
                ggtitle("Density plot of plot volumes") +
                labs(x = "Summed plot volume (m3)", y = "Density")

```

##### By Study Site
```{r echo = FALSE, eval= TRUE, message = FALSE}

        ggplot(data = subplot_sums, aes(x = Treatment, y = Volume_m3, fill = Treatment)) +
                geom_bar(position="dodge", stat="identity") +
                facet_wrap(~ LocalityName, ncol = 5) +
                ggtitle("Plot volumes for SustHerb study sites") +
                labs(x = "Site Treatment", y = bquote("Summed plot volume"~(m^3)))

        ggplot(data = agg_trees, aes(x = Treatment, y = Volume_m3, fill = Taxa)) +
                geom_bar(position="stack", stat="identity") +
                facet_wrap(~ LocalityName, ncol = 5) +
                ggtitle("Plot volumes for SustHerb study sites (by taxa)") +
                labs(x = "Site Treatment", y = bquote("Summed plot volume"~(m^3)))

```

***

#Albedo Estimates {.tabset .tabset-fade .tabset-pills}

## Reasoning
I used the forest **volume-based version of the albedo model** developed by [Hu et al. (2018)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001403) together with snow-water equivalent and temperature data from [seNorge](http://www.senorge.no/) (described earlier) to produce plot-level albedo estimates for the year 2016. The albedo model produces monthly estimates for spruce, pine, and birch forest (which encompasses all other deciduous species). 

I decided that it might be useful to create a **composite albedo** value for each plot (for each month), which would allow for simple comparison of albedos at the plot level. For a given plot in a given month, the first step in creating a composite albedo value is to multiply each species-specific albedo value (produced by the model) with the corresponding species proportions for the plot. This produces three 'fractional albedo' values, which are then summed to produce a 'composite albedo' value:

$$C_{ij} = (A_{ij}S_{jk}) + (A_{ij}S_{jk}) + (A_{ij}S_{jk})\\\;\\C=composite\;albedo\\A = species\mbox{-}specific\;albedo\\S = species\;proportion\\i = month\;(1\mbox{-}12);\;j = plot;\;k = species\;(spruce,\;pine,\;birch)$$

> What do you think about this 'composite albedo'? Is it a reasonable way of assessing albedo across plots?

## Method
1. For a given plot, I ran a function to produce 12 albedo estimates (one for each month of the year)
    + This function incorporated the summed volume (m3) estimate for the plot, as well as 12 values for both average snow-water equivalent (mm) and temperature (K). It used the albedo model form described earlier with species-specific coefficients to produce species-specific albedo estimates for each month of a single year.
    + The function then used the relative proportion of spruce, pine, and birch trees to calculate composite albedos (as described in the reasoning section).
2. For each plot, the function produced a total of *12 composite albedo estimates* (one for each month of the year). Thus, the final albedo dataset contains **360 albedo estimates** (12 per plot, 180 per treatment).

## Results
``` {r echo = FALSE, eval= TRUE, message = FALSE}

        model_data <- read.csv("../../../Approach_1/Output/Albedo_Estimates/albedo_estimates_approach_1.csv")
```

### Albedo {.tabset}

#### Time Series
``` {r echo = FALSE, eval= TRUE, message = FALSE}

        model_data$Month <- as.factor(model_data$Month)
        ggplot(data = model_data, aes(x = Month, y = Composite_Albedo, fill = Treatment)) +
                geom_boxplot() +
                ggtitle("Monthly albedo estimates for SustHerb study sites") +
                labs(x = "Month", y = "Albedo")

```

#### By Site
``` {r echo = FALSE, eval= TRUE, message = FALSE}

        model_data$Month <- as.integer(model_data$Month)
        ggplot(data = model_data, aes(x = Month, y = Composite_Albedo, color = Treatment)) +
                geom_point(alpha = 0.7) +
                geom_line(alpha = 0.3) +
                scale_x_continuous(breaks = c(1,12), limits = c(1,12)) +
                scale_y_continuous(breaks = c(0.0,0.2,0.4,0.6), limits = c(0,0.6)) +
                facet_wrap(~ LocalityName, ncol = 5) +
                ggtitle("Monthly albedo estimates for SustHerb study sites (by site)") +
                labs(x = "Month", y = "Albedo")

```


***

#Model {.tabset .tabset-fade .tabset-pills}

## Correlation Matrix
I created a correlation matrix to investigate possible correlations between continuous explanatory variables (which would ultimately affect the stability of the final model). It appears that *Roe Deer Density* has a relatively strong correlation with moose density.
```{r echo = FALSE, eval= TRUE, message = FALSE}

        ggpairs(data = model_data, columns = c(8:12)) 

```


## Model
Due to the setup of the study design and non-independence of data within each study site (i.e. 2 plots per study site, not independent of each other), I believe we'll need to use a **linear mixed effects model** to model estimated albedo as a function of treatment (moose exclusion). I gave a "first attempt" at a model below - this model was implemented via the *lme4* package in R w/ *lmer* function). As discussed in the 'correlation matrix' section, *Roe Deer Density* was removed as a potential variable due to strong correlation with moose density. I specified the "LocalityName" variable as a random intercept, in order to account for non-independence of data at the level of the study site. The main fixed effect of interest (treatment) was then specified as an interaction with month. 

To select a 'best' model, I started off with a base model with all of the variables of interest, and then eliminated terms that weren't significant. From this 'filtered' model, I created several other versions based on what I thought might be best. I then used the *AIC function* to calculate AIC values for each model. Finally, I chose the model with the lowest AIC value as the 'best' (below).

```{r echo = FALSE, eval= TRUE, message = FALSE}

#Import CSV to dataframe
model_data <- read.csv('../../../Approach_1/Output/Albedo_Estimates/albedo_estimates_approach_1.csv', header = TRUE)
        
        #Format columns
        model_data$Month <- as.factor(model_data$Month)
        model_data$Treatment <- as.factor(model_data$Treatment)
        model_data$LocalityCode <- as.factor(model_data$LocalityCode)
        model_data$LocalityName <- as.factor(model_data$LocalityName)
```

```{r echo = TRUE, eval = FALSE, message = FALSE}
#Initial model:
lmer(Composite_Albedo ~
     Treatment*Month +
     Canopy_Height_MAD +
     Years_Since_Clearcut +
     Moose_Density +
     (1 | LocalityName),
data = model_data)
```

```{r echo = FALSE, eval = TRUE, message = FALSE}
        
#Output
model <- lmer(Composite_Albedo ~
                     Treatment*Month +
                     Canopy_Height_MAD +
                     Years_Since_Clearcut +
                     Moose_Density +
                     (1 | LocalityName),
                data = model_data)
        
tab_model(model, digits = 5)

```

> Is this model correctly specified? Should I be using a non-linear mixed effects model (nlme) instead?

## Diagnosis
It certainly looks like something strange is happening with the residuals. Not sure why there is this linear trend at lower fitted values:

```{r echo = FALSE, eval = TRUE, message = FALSE}

#Output
plot(model)
        
```

***

 
 
 
 