---
output:
  html_document:
    self_contained: false
    lib_dir: libs
    css: styles.css
    toc: true
    df_print: paged
    number_sections: false
    theme: paper
    toc_float:
      collapsed: true
      smooth_scroll: true
    includes:
      before_body: markdown_intro.html
---


```{r echo = FALSE, results = "asis", message = FALSE, include = FALSE}

#Packages
library(dplyr)
library(ggplot2)
library(knitr)
library(kableExtra)
library(sp)
library(raster)
library(GGally)
library(lattice)
library(lme4)
library(sjPlot)
library(ggplot2)
library(RColorBrewer)
library(wesanderson)
library(rasterVis)
library(lidR)
library(geometry)
library(concaveman)

#INITIAL DATA IMPORT + FORMATTING ----------------------------------------------------------------------------------------------

        #Get 'cleaned' site data from adjacent 'Sites' folder
        site_data <- read.csv('../../../Data/SustHerb_Site_Data/cleaned_data/cleaned_data.csv', header = TRUE)
        
        #Load Plot Coordinates

                #Read in Regional coordinates
                plotcoords_trond <- read.csv('../../../Data/Site_Coordinates/troendelag_20m_flater_pkt.csv',header=T,sep=';', dec=',')
                plotcoords_hed_ask <- read.csv('../../../Data/Site_Coordinates/Koordinater_20x20_Hedmark_Akershus.csv',header=T,sep=';', dec=',')
                plotcoords_tel <- read.csv('../../../Data/Site_Coordinates/Koordinater_20x20_Telemark_formatted.csv',header=T,sep=';', dec=',', encoding = "UTF-8")
                
                ##Exclude sites without LiDAR data
                ##  (exclusions based on Ingrid Snøan's 'HedmarkTroendelagTelemarkSustherbSites' file)
                
                        #Hedmark Exclusions
                        hed_excl <- c("DD1", "DD2", "JCD1", "JCD2", "M1.1", "M1.2", "M2.1", "M2.2", "M3.1", "M3.2", "OIA1", "OIA2", "OL1", "OL2", "SK1", "SK2")
                        plotcoords_hed_ask <- plotcoords_hed_ask[!plotcoords_hed_ask$Uthegningi %in% hed_excl,]
                        
                        #Telemark Exclusions
                        tel_excl <- c("Notodden 1 B", "Notodden 1 UB", "Notodden 4 B", "Notodden 4 UB")
                        plotcoords_tel <- plotcoords_tel[!plotcoords_tel$flatenavn %in%  tel_excl,]
                
                #Create df to hold all coordinates
                plotcoords <- data.frame("Name" = '', "utm32north" = '', "utm32east" = '')
                
                        #Bind Trøndelag coordinates to main coordinates df
                        
                                #Filter down to relevant columns
                                plotcoords_trond_opt <- plotcoords_trond[, c(3:5)]

                                #Convert site codes to uppercase (to match 'site_data' format)
                                plotcoords_trond_opt$Name <- toupper(plotcoords_trond_opt$Name)
                                
                                #Rename columns
                                colnames(plotcoords_trond_opt)[2] <- "utm32east"
                                colnames(plotcoords_trond_opt)[3] <- "utm32north"
                                
                                #Correct extra space in '1NSUB' label
                                plotcoords_trond_opt$Name[plotcoords_trond_opt$Name == ' 1NSUB'] <- '1NSUB'
                
                                #Row bind with main coordinates df
                                plotcoords <- plotcoords_trond_opt
                                
                        #Bind Askerhus + Hedmark coordinates to main coordinates df
                                
                                #Filter down to relevant columns
                                plotcoords_hed_ask_opt <- plotcoords_hed_ask[, c(6, 14:15)]
                                
                                #Rename 'Name' column
                                colnames(plotcoords_hed_ask_opt)[1] <- "Name"
                                
                                #Swap 'coordinate codes' with SustHerb site codes
                                #Note: Using Ingrid's coordinate references here (number order b/t B and UB is a bit wonky)
                                
                                        #Didrik Holmsen UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'DH1'] <- 'DHUB'
                                        
                                        #Didrik Holmsen B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'DH2'] <- 'DHB'
                                        
                                        #Fet3 UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'FK1'] <- 'FKUB'
                                        
                                        #Fet3 B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'FK2'] <- 'FKB'
                                        
                                        #Halvard Pramhus UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'HP2'] <- 'HPUB'
                                        
                                        #Halvard Pramhus B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'HP1'] <- 'HPB'
                                        
                                        #Stig Dahlen UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SD1'] <- 'SDUB'
                                        
                                        #Stig Dahlen B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SD2'] <- 'SDB'
                                        
                                        #Stangeskovene Aurskog UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SSA2'] <- 'SSAUB'
                                        
                                        #Stangeskovene Aurskog B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SSA1'] <- 'SSAB'
                                        
                                        #Stangeskovene Eidskog UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SSB2'] <- 'SSBUB'
                                        
                                        #Stangeskovene Eidskog B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'SSB1'] <- 'SSBB'
                                        
                                        #Eidskog UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'STSKN1'] <- 'STSKNUB'
                                        
                                        #Eidskog B
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'STSKN2'] <- 'STSKNB'
                                        
                                        #Truls Holm UB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'TH2'] <- 'THUB'
                                        
                                        #Truls Holm BB
                                        plotcoords_hed_ask_opt$Name[plotcoords_hed_ask_opt$Name == 'TH1'] <- 'THB'
                                        
                                        
                                        
                                        
                                #Row bind with main coordinates df
                                plotcoords <- rbind(plotcoords, plotcoords_hed_ask_opt)
                                
                        #Bind Telemark coordinates to main coordinates df
                                
                                #Filter down to relevant columns
                                plotcoords_tel_opt <- plotcoords_tel[, c(4, 9:10)]
                                
                                #Correct column names
                                colnames(plotcoords_tel_opt)[1] <- "Name"

                                #Remove unicode 'replacement character' in "Fritsoe" (to match site_data)
                                plotcoords_tel_opt$Name <- gsub('\uFFFD', 'o', plotcoords_tel_opt$Name)
                                
                                #Corrections to spelling (to match 'site_data' and allow for loop below)
                                        
                                        #Column to lowercase
                                        plotcoords_tel_opt$Name <- tolower(plotcoords_tel_opt$Name)
                                        
                                        #Fritsoe
                                        plotcoords_tel_opt$Name <- gsub('fritzoe', 'fritsoe', plotcoords_tel_opt$Name)
                                        
                                        #Cappelen
                                        plotcoords_tel_opt$Name <- gsub('cappelen', 'nome_cappelen', plotcoords_tel_opt$Name)
                                
                                        #Furesdal (Note: remove number '1' to match 'site_data')
                                        plotcoords_tel_opt$Name <- gsub('fyresdal 1', 'furesdal', plotcoords_tel_opt$Name)
                                
                                #Replace full name w/ relevant site code
                                        
                                        for(i in 1:nrow(plotcoords_tel_opt)){
                                                
                                                #Split string
                                                s <- strsplit(plotcoords_tel_opt[i, "Name"], split = " ")
                                                
                                                #Perform code below for all except furesdal
                                                if( s[[1]][1] == "furesdal" ){
                                                        
                                                        #Grab 'furesdal' string
                                                        s2 <- s[[1]][1]
                                                        
                                                        #Identify treatment
                                                        st <- s[[1]][2]
                                                        
                                                } else {
                                                        
                                                        #Join site name + number
                                                        s2 <- paste(s[[1]][1], s[[1]][2], sep = "")
                                                        
                                                        #Identify treatment
                                                        st <- s[[1]][3]
                                                        
                                                }
                                                
                                                if( st == "ub" ){
                                                        tr <- "exclosure"
                                                } else if ( st == "b" ){
                                                        tr <- "open"
                                                }
                                                
                                                #Get relevant site code
                                                ## Some sites not in site_data (these are given NA)
                                                if( (s2 %in% site_data$LocalityName) == T ) {
                                                        sc <- site_data$LocalityCode[site_data$LocalityName == s2 & site_data$Treatment == tr]
                                                } else {
                                                        sc <- NA
                                                }
                                                
                                                #Replace existing name w/ site code (or NA)
                                                plotcoords_tel_opt[i, "Name"] <- sc
                                                
                                        }

                                #Row bind with main coordinates df
                                plotcoords <- rbind(plotcoords, plotcoords_tel_opt)
                

#END INITIAL DATA IMPORT + FORMATTING --------------------------------------------------------------------------------
```
                                
                                
                                
                                
    

# Overview
This report contains a summary of 'Approach 2', which uses existing SustHerb LiDAR data from [Snøan (2019)](https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2618099?locale-attribute=no) and a 'convex hull' method to estimate volume (and ultimately, albedo) for relevant study plots. The report covers each step of the analysis and discusses potential limitations/assumptions associated with each step.

![](https://allyworks.io/moose-albedo/img/Approach_2_Flowchart.png)

***

# Data

### Data Selection {.tabset .tabset-fade .tabset-pills}

#### SustHerb Data
I chose to use data from SustHerb sites in Trøndelag, Telemark, and Hedmark **(n = 37)**. LiDAR data for these sites was previously processed by [Snøan (2019)](https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2618099?locale-attribute=no) - thus, I was able to use this LiDAR data as a starting point for my analysis. It is important to note that the following SustHerb sites are missing from my analysis (as they were missing from the analysis conducted by [Snøan (2019)](https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2618099?locale-attribute=no) and therefore, don't have existing LiDAR data):

* **Hedmark**: "DD1", "DD2", "JCD1", "JCD2", "M1.1", "M1.2", "M2.1", "M2.2", "M3.1", "M3.2", "OIA1", "OIA2", "OL1", "OL2", "SK1", "SK2"
* **Telemark**: "Notodden 1 B", "Notodden 1 UB", "Notodden 4 B", "Notodden 4 UB"

Additional variables for each plot that were included in the final model/analysis include "Years Since Exclosure" and "Number of Years Between Clearcut and LiDAR Measurement".

#### seNorge Climate Data
The albedo model developed by [Hu et al. (2018)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001403) accepts *two climate parameters*: (1) monthly average snow-water equivalent (mm) and (2) monthly average temperature (K). seNorge provides this data across the entire country of Norway in the form of spatially-gridded daily estimates with a 1km2 resolution. Thus, it was possible to use obtain relevant time series data for each study site used in this approach.

For each study site, I pulled snow-water equivalent and temperature data from the corresponding year of LiDAR measurement - so, for example, if a plot was measured with LiDAR in 2016, then I pulled climate data corresponding to that plot from 2016. Monthly averages of temperature (C) and snow-water equivalent (mm) were calculated from each time series. Temperature was converted to K for use with the albedo model. **The total number of temperature observations is therefore 444 (12 months x 37 sites). The total number of snow-water equivalent observations is also 444 (12 months x 37 sites)**.

#### Productivity Index
Site productivity is likely an important variable to control for when attempting to determine the effect of moose exclusion on forest surface albedo. Therefore, I decided to include data from the site productivity index that was developed by [Kolstad et al. (2017)](https://link.springer.com/article/10.1007/s10021-017-0202-4). This index is based upon a standardized value for mean annual increment in aboveground biomass. 

#### Herbivore Densities
Densities of various herbivores may have important effects on vegetation states within forest ecosystems, and therefore, it is likely relevant to control for relevant herbivore densities in our final analysis. In addition to moose, both red deer and roe deer are important herbivores in Norwegian boreal forests. Thus, I decided to include densities of moose, red deer, and roe deer in the final model for this approach.

[Speed et al. (2019)](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0217166) and [Austrheim et al. (2011)](https://bioone.org/journals/Wildlife-Biology/volume-17/issue-3/10-038/Spatio-temporal-variation-in-large-herbivore-pressure-in-Norway-during/10.2981/10-038.full) calculated metabolic biomass (kg/km2) of many different large herbivores in each Norwegian municipality (for 1949, 1959, 1969, 1979, 1989, 1999, 2009, and 2015), which allows us to include herbivore densities as covariates in our final model.

For simplicity's sake, I decided to use herbivore data from 2015 for all SustHerb sites in this approach. However, some sites have LiDAR data closer to 2009 than to 2015 (ex. "namdalseid_1kub" has LiDAR data from 2010). It might be worth it to re-do the analysis and grab herbivore densities from the year closest to that of the LiDAR data for each site. I could then include "herbivore data year" as a categorical variable in the final model, if necessary.

> What is your opinion of using 2015 data for all sites? Should I re-do the analysis as described above?

#### Forest Canopy Height MAD
Surface roughness (and therefore forest canopy roughness) may be an important factor in surface albedo. [Snøan (2019)](https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2618099?locale-attribute=no) used airborne laser measurements (LiDAR) to examine the effects of moose exclusion on boreal forest canopy, and found that moose exclusion significantly altered forest canopy height mean absolute deviation (MAD), which is a metric for canopy roughness. Therefore, I decided to include the LiDAR-derived canopy MAD measurements produced by [Snøan (2019)](https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2618099?locale-attribute=no) in the final analysis for this approach.

### Data Summary {.tabset .tabset-fade .tabset-pills}

#### SustHerb Dataset {.tabset}

##### Summary
```{r echo = FALSE, eval= TRUE, message = FALSE}

        simple_sites <- site_data[,c(2,3,5,7,10,12,23)]

        #Taxa Table
        simple_sites

```

##### Tree Species Proportions
```{r echo = FALSE, eval= TRUE, message = FALSE}   

## SUSTHERB TREE SPECIES PROPORTIONS (At the PLOT level)
                        
#Tree density data for Trøndelag, Telemark, and Hedmark (including 2019 data)
tree_data <- read.csv('../../../Universal/Output/Tree_Species_Proportions/tree_species_proportions_plot_level.csv', header = TRUE)
tree_data <- tree_data[,2:7]

#Filter tree data to years that correspond with LiDAR Data
## Ex. BRB has LiDAR data from 2017, so get tree data from 2017 only

#Note: This also reduces the number of sites to 74 (as in Ingrid Snøan's analysis)

        #Filter out unused SustHerb sites
                
                #Convert site codes to factors
                tree_data$LocalityCode <- as.factor(tree_data$LocalityCode)
                site_data$LocalityCode <- as.factor(site_data$LocalityCode)
                
                #Get vector of levels for sites that will be used (n = 74)
                used_sites <- levels(site_data$LocalityCode)
                
                #Filter tree data to used sites
                tree_data <- tree_data[tree_data$LocalityCode %in% used_sites,]
                tree_data$LocalityCode <- as.factor(as.character(tree_data$LocalityCode))
                
        #For each site, filter out data from irrelevant years
        for(i in 1:length(site_data$X)){
                
                #Get site code and corresponding LiDAR year
                site_code <- site_data[i, "LocalityCode"]
                lidar_year <- site_data[i, "LiDAR.data.from.year"]
                
                #Filter down tree data (from all)
                
                #Get temp frame
                temp <- tree_data[tree_data$LocalityCode == site_code & tree_data$Year == lidar_year,]
                
                #Subtract observations w/ corresponding site code
                tree_data <- tree_data[tree_data$LocalityCode != site_code,]
                
                #Re-add temp frame
                tree_data <- rbind(tree_data, temp)
                
        }
        
        #Display df    
        tree_data
        
      
```

#### seNorge Data {.tabset}

##### Snow-Water Equivalent
```{r echo = FALSE, eval= TRUE, message = FALSE}        
        
        #Add monthly SWE averages from seNorge
        swe <- read.csv('../../../Universal/Output/SWE/monthly_avg_swe_mm.csv', header = TRUE)
                
        #Add monthly temperature averages from seNorge
        temps <- read.csv('../../../Universal/Output/Temperature/monthly_avg_temp_C.csv', header = TRUE)

                #Convert temps from celsius (C) to kelvin (K)
                for( i in 1:length(temps$X)){
                        #K = C + 273.15
                        temps[i, "Avg_Temp_C"] <- temps[i, "Avg_Temp_C"] + 273.15
                }
        
                #Rename column from C to K
                colnames(temps)[9] <- "Avg_Temps_K"
                
        #Remove sites not used in analysis
        site_data$LocalityCode <- as.factor(site_data$LocalityCode)
        swe$LocalityCode <- as.factor(swe$LocalityCode)
        temps$LocalityCode <- as.factor(temps$LocalityCode)
        
        checklist <- site_data[site_data$Treatment == "open",]
        checklist <- levels(as.factor(as.character(checklist$LocalityCode)))
        swe_filtered <- swe[swe$LocalityCode %in% checklist,]
        temps_filtered <- temps[temps$LocalityCode %in% checklist,]
        
        #Plot
        swe_filtered$Month <- as.numeric(swe_filtered$Month)
        ggplot(data = swe_filtered, aes(x = Month, y = SWE_mm, color = LocalityName)) +
                        geom_line() +
                        ggtitle("Monthly Avg. SWE at SustHerb Sites (n = 37)") +
                        labs(x = "Month", y = "SWE (mm)") +
                        scale_x_continuous(limits = c(0,12), breaks = c(1,2,3,4,5,6,7,8,9,10,11,12)) +
                        theme(
                                legend.position = "none"
                        )
        
        ggplot(data = swe_filtered, aes(x = Month, y = SWE_mm, color = LocalityName)) +
                geom_line() +
                facet_wrap(~ Year) +
                ggtitle("Monthly Avg. SWE at SustHerb Sites (n = 37)\n(by Corresponding Year of LiDAR Data)") +
                labs(x = "Month", y = "SWE (mm)") +
                scale_x_continuous(limits = c(0,12), breaks = c(1,2,3,4,5,6,7,8,9,10,11,12)) +
                theme(
                        legend.position = "none"
                )

        swe_filtered$Month <- as.factor(swe_filtered$Month)
        ggplot(data = swe_filtered, aes(x = Month, y = SWE_mm)) +
                geom_boxplot() +
                ggtitle("Monthly Avg. SWE at SustHerb Sites by Month (n = 37)") +
                labs(x = "Month", y = "SWE (mm)")
        
        ggplot(data = swe_filtered, aes(x = SWE_mm)) +
                geom_histogram() +
                facet_wrap(~ Month) +
                ggtitle("Monthly Avg. SWE at SustHerb Sites by Month (n = 37)") +
                labs(x = "Avg. SWE (mm)", y = "Count")
        
```

##### Temperature
```{r echo = FALSE, eval= TRUE, message = FALSE}        

        #Plot
        temps_filtered$Month <- as.numeric(temps_filtered$Month)
        ggplot(data = temps_filtered, aes(x = Month, y = Avg_Temps_K, color = LocalityName)) +
                        geom_line() +
                        ggtitle("Monthly Avg. Temperature at SustHerb Sites (n = 37)") +
                        labs(x = "Month", y = "Temperature (K)") +
                        scale_x_continuous(limits = c(0,12), breaks = c(1,2,3,4,5,6,7,8,9,10,11,12)) +
                        theme(
                                legend.position = "none"
                        )
        
        ggplot(data = temps_filtered, aes(x = Month, y = Avg_Temps_K, color = LocalityName)) +
                geom_line() +
                facet_wrap(~ Year) +
                ggtitle("Monthly Avg. Temperature at SustHerb Sites (n = 37)\n(by Corresponding Year of LiDAR Data)") +
                labs(x = "Month", y = "Temperature (K)") +
                scale_x_continuous(limits = c(0,12), breaks = c(1,2,3,4,5,6,7,8,9,10,11,12)) +
                theme(
                        legend.position = "none"
                )

        temps_filtered$Month <- as.factor(temps_filtered$Month)
        ggplot(data = temps_filtered, aes(x = Month, y = Avg_Temps_K)) +
                geom_boxplot() +
                ggtitle("Monthly Avg. Temperature at SustHerb Sites by Month (n = 37)") +
                labs(x = "Month", y = "Avg. Temperature (K)")
        
        ggplot(data = temps_filtered, aes(x = Avg_Temps_K)) +
                geom_histogram() +
                facet_wrap(~ Month) +
                ggtitle("Monthly Avg. Temperature at SustHerb Sites by Month (n = 37") +
                labs(x = "Avg. Temperature (K)", y = "Count")


```

#### Productivity Index
```{r echo = FALSE, eval = TRUE, message = FALSE}

#Productivity Data
productivity <- read.csv('../../../Data/SustHerb_Site_Data/productivity_all_sites.csv', header = TRUE)
productivity$LocalityName <- tolower(productivity$LocalityName)

        #Correct LocalityName items in productivity CSV
        
                #Didrik Holmsen
                productivity$LocalityName[productivity$LocalityName == "didrik holmsen"] <- "didrik_holmsen"
                
                #Fet 3
                productivity$LocalityName[productivity$LocalityName == "fet 3"] <- "fet_3"
                
                #Fritsøe 1
                productivity$LocalityName[productivity$LocalityName == "fritsøe1"] <- "fritsoe1"
                
                #Fritsøe 2
                productivity$LocalityName[productivity$LocalityName == "fritsøe2"] <- "fritsoe2"
                
                #Halvard Pramhus
                productivity$LocalityName[productivity$LocalityName == "halvard pramhus"] <- "halvard_pramhus"
                
                #Singsaas
                productivity$LocalityName[productivity$LocalityName == "singsås"] <- "singsaas"
                
                #Stangeskovene Aurskog
                productivity$LocalityName[productivity$LocalityName == "stangeskovene aurskog"] <- "stangeskovene_aurskog"
                
                #Stangeskovene Eidskog
                productivity$LocalityName[productivity$LocalityName == "stangeskovene eidskog"] <- "stangeskovene_eidskog"
                
                #Stig Dahlen
                productivity$LocalityName[productivity$LocalityName == "stig dæhlen"] <- "stig_dahlen"
                
                #Truls Holm
                productivity$LocalityName[productivity$LocalityName == "truls holm"] <- "truls_holm"

        #Create corrected version of checklist
        checklist2 <- as.vector('')
        for(i in 1:length(checklist)){
                checklist2[i] <- site_data$LocalityName[site_data$LocalityCode == checklist[i]]
        }

        #Remove LocalityNames not in tree dataset
        productivity <- productivity[productivity$LocalityName %in% checklist2,]
        prod_display <- productivity[,2:4]
        
        prod_display
        
        ggplot(data = prod_display, aes(x = Productivity)) +
                geom_histogram() +
                ggtitle("Productivity Index Across SustHerb Sites") +
                labs(x = "Productivity Index", y = "Count")
        
```

#### Herbivore Densities
```{r echo = FALSE, eval = TRUE, message = FALSE}

        #Read in herbivore biomass data from SpatialPolygons object (isolate dataframe)
        hbiomass_shp <- shapefile("../../../Data/Herbivore_Densities/NorwayLargeHerbivores")
        
        #Pull out dataframe
        hbiomass <- hbiomass_shp@data
        
        #Isolate 2015 data
        hbiomass2015 <- cbind(hbiomass[,c(1:10)], hbiomass$Ms_2015, hbiomass$Rd__2015, hbiomass$R_d_2015)
        
        #Get list of Kommune IDs
        site_data$DistrictID <- as.factor(site_data$DistrictID)
        kommunes <- levels(site_data$DistrictID)
        
        #Create placeholder df w/ 37 blank rows
        herb_dens_display <- data.frame("LocalityName" = character(),
                                        "Moose_Density" = double(),
                                        "Red_Deer_Density" = double(),
                                        "Roe_Deer_Density" = double(),
                                        "Lidar_Year" = integer(),
                                        "Herbivore_Data_Year" = integer())
        herb_dens_display[nrow(herb_dens_display)+37,] <- NA
        
        for(i in 1:length(checklist2)){
                
                #Get LocalityName
                herb_dens_display[i, "LocalityName"] <- checklist2[i]
                
                #District ID
                d_id <- as.character(site_data$DistrictID[site_data$LocalityName == checklist2[i]][1])
                
                #Get LiDAR year
                lidar_yr <- site_data$LiDAR.data.from.year[site_data$LocalityName == checklist2[i]][1]
                herb_dens_display[i, "Lidar_Year"] <- lidar_yr
                
                #Assign Herbivore Density Info
                herb_dens_display[i, "Herbivore_Data_Year"] <- 2015
                herb_dens_display[i, "Moose_Density"] <- hbiomass2015$`hbiomass$Ms_2015`[hbiomass2015$KOMMUNE == d_id]
                herb_dens_display[i, "Red_Deer_Density"] <- hbiomass2015$`hbiomass$Rd__2015`[hbiomass2015$KOMMUNE == d_id]
                herb_dens_display[i, "Roe_Deer_Density"] <- hbiomass2015$`hbiomass$R_d_2015`[hbiomass2015$KOMMUNE == d_id]
                

        }
        
        #Display df
        herb_dens_display
        
        #Mutate df for plotting
        herb_dens_plot <- data.frame("LocalityName" = character(),
                                        "Density" = double(),
                                        "Herbivore" = double(),
                                        "Herbivore_Data_Year" = integer())
        
        for(i in 1:nrow(herb_dens_display)){
                
                tmp <- data.frame("LocalityName" = character(),
                                        "Density" = double(),
                                        "Herbivore" = double(),
                                        "Herbivore_Data_Year" = integer())
                tmp[nrow(tmp)+(3),] <- NA
                
                tmp$LocalityName <- herb_dens_display[i, "LocalityName"]
                tmp$Herbivore_Data_Year <- herb_dens_display[i, "Herbivore_Data_Year"]
                
                #Moose Density
                tmp[1, "Density"] <- herb_dens_display[i, "Moose_Density"]
                tmp[1, "Herbivore"] <- "Moose"
                
                #Red Deer Density
                tmp[2, "Density"] <- herb_dens_display[i, "Red_Deer_Density"]
                tmp[2, "Herbivore"] <- "Red Deer"
                
                #Roe Deer Density
                tmp[3, "Density"] <- herb_dens_display[i, "Roe_Deer_Density"]
                tmp[3, "Herbivore"] <- "Roe Deer"
                
                herb_dens_plot <- rbind(herb_dens_plot, tmp)
        }
        
        ggplot(data = herb_dens_plot, aes(x = Herbivore, y = Density)) +
                geom_boxplot() +
                ggtitle("Herbivore Densities Across SustHerb Sites (n = 37)") +
                labs(x = "Herbivore", y = "Metabolic Density (kg/km2)")
                
        
```

***

#Volume Calculations {.tabset .tabset-fade .tabset-pills}

## Reasoning 

##### Using LiDAR to calculate volumes of convex hulls around trees:
**The goal with this step was to calculate the volumes of "convex hulls" around each tree in a given plot**, which could then be summed and used as the 'volume' parameter in the volume-based albedo model developed by [Hu et al. (2018)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001403). Established methods could be used to identify and delineate inidividual trees within a LiDAR footprint of each SustHerb plot (specifically, by using the [lidR package](https://github.com/Jean-Romain/lidR) and associated methods).

For each set of LiDAR points associated with a given delineated tree, I thought it might then be possible to use the methods somewhat similar to those used by [Yan et al. (2019)](https://www.sciencedirect.com/science/article/pii/S0168192314001750) to construct a "3D convex hull" (i.e. a convex geometry with as few points as possible) around those LiDAR points and ultimately, estimate the volume of the tree. I believe this is similar to a tree "crown volume" metric.

I could then sum the crown volumes for each delineated tree in a plot to produce a plot-level estimate of volume (I guess in this approach, the "type" of volume metric would be "summed crown volume"). These volumes would then be summed at the plot level and used to estimate albedo for each plot. 

## Methods

1. Read in LAS files from Snøan (2019) (n = 37)
2. For each LAS file:
    + Projected to UTM32 CRS
    + Generated a digital terrain model (DTM) for the file
        + Used a k-nearest neighbors algorithm and a pixel resolution of 0.5m2
    + Used the DTM to "normalize" the LiDAR data (i.e. remove surface topography)
    + Generated a canopy height model (CHM) from the "normalized" LAS file
        + Used the lidR package [wiki](https://github.com/Jean-Romain/lidR/wiki/Segment-individual-trees-and-compute-metrics) to reduce pits in the CHM (i.e. used the pitfree alogrithm)
    + Used the watershed algorithm and LAS_trees function to segment and delineate individual trees (with a minimum tree height threshold of 1m)
    + Filtered out LiDAR points associated with trees >7m in height, as in Snøan (2019)
    + Clipped filtered LAS file to 20x20m square (based on plot coordinates)
    + For each remaining tree, used the [rLiDAR package](https://cran.r-project.org/web/packages/rLiDAR/rLiDAR.pdf) to calculate a convex hull around the LiDAR points associated with that tree
        + The volume of this hull was set to be the volume of the associated tree
    + Summed the volumes of all trees in the plot to produce a **plot-level volume estimate**
    
    
## Results

#### Volume {.tabset}


##### Boxplot

![](https://allyworks.io/moose-albedo/img/plot_volumes_approach_2.png)


##### Density Plot
![](https://allyworks.io/moose-albedo/img/plot_volumes_density_approach_2.png)


##### By Study Site
![](https://allyworks.io/moose-albedo/img/plot_volumes_faceted_approach_2.png)


##### Tree Hulls
I've provided a few images here which show the 2D footprints of the associated 3D convex hulls for each tree in a plot (hull footprints are illustrated with green lines). It appears that 2 things are happening with this approach:

* (1) Individual trees are not well delineated, and instead, are often grouped together into large convex hulls. This seems to be particularly apparent in exclosures, where the canopy is denser and harder to delineate. Ultimately, this approach is probably overestimating tree volumes in exclosures.
* (2) Small trees in open plots (which are kept small through browsing) are not picked up by this method. Therefore, it is likely that the method underestimates tree volumes in open plots.

![](https://allyworks.io/moose-albedo/img/bratsberg_ub.png)

![](https://allyworks.io/moose-albedo/img/drangedal1_ub.png)

![](https://allyworks.io/moose-albedo/img/drangedal4_ub.png)

![](https://allyworks.io/moose-albedo/img/notodden5_b.png)

![](https://allyworks.io/moose-albedo/img/sl_tydal_b.png)

***

#Albedo Estimates {.tabset .tabset-fade .tabset-pills}

## Reasoning
I used the forest **volume-based version of the albedo model** developed by [Hu et al. (2018)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001403) together with snow-water equivalent and temperature data from [seNorge](http://www.senorge.no/) (described earlier) to produce plot-level albedo estimates for the years corresponding with those in which LiDAR measurements were recorded for each plot. The albedo model produces monthly estimates for spruce, pine, and birch forest (which encompasses all other deciduous species). 

I decided that it might be useful to create a **composite albedo** value for each plot (for each month), which would allow for simple comparison of albedos at the plot level. For a given plot in a given month, the first step in creating a composite albedo value is to multiply each species-specific albedo value (produced by the model) with the corresponding species proportions for the plot. This produces three 'fractional albedo' values, which are then summed to produce a 'composite albedo' value:

$$C_{ij} = (A_{ij}S_{jk}) + (A_{ij}S_{jk}) + (A_{ij}S_{jk})\\\;\\C=composite\;albedo\\A = species\mbox{-}specific\;albedo\\S = species\;proportion\\i = month\;(1\mbox{-}12);\;j = plot;\;k = species\;(spruce,\;pine,\;birch)$$

> What do you think about this 'composite albedo'? Is it a reasonable way of assessing albedo across plots?

## Method
1. For a given plot, I ran a function to produce 12 albedo estimates (one for each month of the year)
    + This function incorporated the summed volume (m3) estimate for the plot, as well as 12 values for both average snow-water equivalent (mm) and temperature (K). Snow-water equivalent and temperature data were produced from the year corresponding to that in which the LiDAR measurements of the plot were obtained. The function used the albedo model form described earlier with species-specific coefficients to produce species-specific albedo estimates for each month of a single year.
    + The function then used the relative proportion of spruce, pine, and birch trees to calculate composite albedos (as described in the reasoning section).
2. For each plot, the function produced a total of *12 composite albedo estimates* (one for each month of the year). Thus, the final albedo dataset contains **888 albedo estimates** (12 per plot, 444 per treatment).

## Results
``` {r echo = FALSE, eval= TRUE, message = FALSE}

        model_data <- read.csv("../../../Approach_2/Output/Albedo_Estimates/albedo_estimates_approach_2.csv")

```

### Albedo {.tabset}

#### Time Series
``` {r echo = FALSE, eval= TRUE, message = FALSE}

        model_data$Month <- as.factor(model_data$Month)
        ggplot(data = model_data, aes(x = Month, y = Composite_Albedo, fill = Treatment)) +
                geom_boxplot() +
                ggtitle("Monthly albedo estimates for SustHerb study sites (n = 37)") +
                labs(x = "Month", y = "Albedo")

```

#### By Site
``` {r echo = FALSE, eval= TRUE, message = FALSE}

        model_data$Month <- as.integer(model_data$Month)
        ggplot(data = model_data, aes(x = Month, y = Composite_Albedo, color = Treatment)) +
                geom_line(alpha = 0.8) +
                scale_x_continuous(breaks = c(1,12), limits = c(1,12)) +
                scale_y_continuous(breaks = c(0.0,0.2,0.4,0.6), limits = c(0,0.6)) +
                facet_wrap(~ LocalityName, ncol = 8) +
                ggtitle("Monthly albedo estimates for SustHerb study sites (by site)") +
                labs(x = "Month", y = "Albedo")

```

***

#Model {.tabset .tabset-fade .tabset-pills}

## Correlation Matrix
I created a correlation matrix to investigate possible correlations between continuous explanatory variables (which would ultimately affect the stability of the final model). It appears that *Roe Deer Density* is moderately correlated with moose density, but I'm not sure if this correlation is strong enough to warrant removal from the final model.

```{r echo = FALSE, eval= TRUE, message = FALSE}

        ggpairs(data = model_data, columns = c(8:13)) 

```


## Model
Due to the setup of the study design and non-independence of data within each study site (i.e. 2 plots per study site, not independent of each other), I believe we'll need to use a **linear mixed effects model** to model estimated albedo as a function of treatment (moose exclusion). I gave a "first attempt" at a model below - this model was implemented via the *lme4* package in R w/ *lmer* function). I specified the "LocalityName" variable as a random intercept, in order to account for non-independence of data at the level of the study site. The main fixed effect of interest (treatment) was then specified as an interaction with month. 

To select a 'best' model, I started off with a base model with all of the variables of interest (as well as 2-way interaction terms), and then created a 'filtered' model by eliminating terms that weren't significant. I also created a 'simple' model, which only included variables that I thought would be most relevant. I then used the *AIC function* to calculate AIC values for each model. Finally, I chose the model with the lowest AIC value as the 'best' (below).

```{r echo = FALSE, eval= TRUE, message = FALSE}

        #Format columns
        model_data$Month <- as.factor(model_data$Month)
        model_data$Treatment <- as.factor(model_data$Treatment)
        model_data$LocalityCode <- as.factor(model_data$LocalityCode)
        model_data$LocalityName <- as.factor(model_data$LocalityName)
        
        #Relevel factors to use 'browsed' as the control/reference
        model_data$Treatment <- relevel(model_data$Treatment, ref = "open")

```

```{r echo = TRUE, eval = FALSE, message = FALSE}
#Initial model:
lmer(Composite_Albedo ~
               Treatment*Month +
               Clearcut_Lidar +
               Moose_Density +
               Canopy_Height_MAD +
               (1 | LocalityName),
        data = model_data)
```

```{r echo = FALSE, eval = TRUE, message = FALSE}
        
#Output
model <- lmer(Composite_Albedo ~
                       Treatment*Month +
                       Clearcut_Lidar +
                       Moose_Density +
                       Canopy_Height_MAD +
                       (1 | LocalityName),
               data = model_data)
        
tab_model(model, digits = 5)

```

> Is this model correctly specified? Should I be using a non-linear mixed effects model (nlme) instead?

## Diagnosis
It certainly looks like something strange is happening with the residuals. Not sure why there is this linear trend at lower fitted values:

```{r echo = FALSE, eval = TRUE, message = FALSE}

#Output
plot(model)
        
```

***

# Next Steps?

##### Abandon this approach?
It seems that this approach may not be suitable for the purposes of calculating albedo across SustHerb study sites. 

***

 
 
 